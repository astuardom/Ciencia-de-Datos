#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
K-Means: Segmentaci√≥n de Clientes (Ejercicio sin soluci√≥n)
Dataset sugerido: "Mall Customers" (Kaggle)
URL de referencia (b√∫scalo en Kaggle): Mall Customers Dataset

------------------------------------------------------------------------------
INSTRUCCIONES (resumen):
1) Descarga el dataset desde Kaggle y col√≥calo en la carpeta ./input/
   - Archivo t√≠pico: Mall_Customers.csv
2) Crea un entorno virtual e instala dependencias:
   - pip install numpy pandas matplotlib scikit-learn
3) Ejecuta este script desde la terminal:
   - python KMeans_MallCustomers_Entregable.py
4) Sigue los TODOs. NO hay soluciones implementadas.

------------------------------------------------------------------------------
REQUISITOS DEL ENTREGABLE:
- Trabajar con 2 variables num√©ricas (p. ej., "Annual Income (k$)" y "Spending Score (1-100)")
- Probar varios K (2..7), mostrar:
    (i) Curva del codo (SSE vs K)
    (ii) Silueta vs K
- Elegir un K y justificarlo en comentarios
- Entrenar K-Means con ese K y reportar m√©tricas (SSE, Silhouette) y centroides
- Guardar todas las figuras en ./output_kmeans/ y mostrarlas en pantalla
- Exportar un CSV con etiquetas de cluster y, si escalas, reportar centroides en escala original

------------------------------------------------------------------------------
NOTAS:
- No uses seaborn (opcional) para cumplir entornos con restricciones.
- Cuida la reproducibilidad (semilla fija).
- Documenta tus decisiones en comentarios dentro del c√≥digo.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sklearn
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score
import os
import warnings
warnings.filterwarnings('ignore')

# Configuraci√≥n para reproducibilidad
np.random.seed(42)

# Configuraci√≥n de matplotlib para mejor visualizaci√≥n
plt.style.use('default')
plt.rcParams['figure.figsize'] = (12, 8)
plt.rcParams['font.size'] = 12

def crear_directorios():
    """
    Crea los directorios necesarios para el ejercicio
    """
    # TODO 1: Crear directorios input/ y output_kmeans/ si no existen
    # Usa os.makedirs() con exist_ok=True
    
    os.makedirs('input', exist_ok=True)
    os.makedirs('output_kmeans', exist_ok=True)
    print("‚úÖ Directorios creados/verificados: input/ y output_kmeans/")

def cargar_datos():
    """
    Carga el dataset Mall Customers desde el archivo CSV
    """
    # TODO 2: Cargar el dataset desde ./input/Mall_Customers.csv
    # Usa pd.read_csv() y verifica que se carg√≥ correctamente
    
    try:
        df = pd.read_csv('./input/Mall_Customers.csv')
        print(f"‚úÖ Dataset cargado exitosamente: {df.shape}")
        
        # TODO 3: Mostrar informaci√≥n b√°sica del dataset:
        # - shape
        # - info()
        # - head()
        # - describe()
        
        print(f"\nüìä Informaci√≥n del dataset:")
        print(f"Shape: {df.shape}")
        print(f"Columnas: {list(df.columns)}")
        
        print(f"\nüìã Primeras 5 filas:")
        print(df.head())
        
        print(f"\nüìà Estad√≠sticas descriptivas:")
        print(df.describe())
        
        # TODO 4: Verificar si hay valores faltantes y manejarlos apropiadamente
        
        print(f"\nüîç Verificaci√≥n de valores faltantes:")
        missing_values = df.isnull().sum()
        if missing_values.sum() == 0:
            print("‚úÖ No hay valores faltantes en el dataset")
        else:
            print("‚ö†Ô∏è Valores faltantes encontrados:")
            print(missing_values[missing_values > 0])
            # Eliminar filas con valores faltantes
            df = df.dropna()
            print(f"Dataset limpio: {df.shape}")
        
        return df
        
    except FileNotFoundError:
        print("‚ùå Error: Archivo Mall_Customers.csv no encontrado en ./input/")
        print("üí° Aseg√∫rate de descargar el dataset desde Kaggle y colocarlo en la carpeta input/")
        return None
    except Exception as e:
        print(f"‚ùå Error al cargar datos: {e}")
        return None

def explorar_datos(df):
    """
    Realiza exploraci√≥n b√°sica de los datos
    """
    # TODO 5: Crear visualizaciones exploratorias:
    # - Histogramas de las variables num√©ricas
    # - Matriz de correlaci√≥n (heatmap)
    # - Scatter plot de las dos variables principales que usar√°s
    
    print("üìä Creando visualizaciones exploratorias...")
    
    # Seleccionar solo variables num√©ricas
    numeric_cols = df.select_dtypes(include=[np.number]).columns
    print(f"Variables num√©ricas encontradas: {list(numeric_cols)}")
    
    # Crear figura con subplots
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    fig.suptitle('An√°lisis Exploratorio - Mall Customers Dataset', fontsize=16)
    
    # 1. Histogramas de variables num√©ricas
    for i, col in enumerate(numeric_cols):
        row = i // 2
        col_idx = i % 2
        axes[row, col_idx].hist(df[col], bins=20, alpha=0.7, edgecolor='black')
        axes[row, col_idx].set_title(f'Distribuci√≥n de {col}')
        axes[row, col_idx].set_xlabel(col)
        axes[row, col_idx].set_ylabel('Frecuencia')
        axes[row, col_idx].grid(True, alpha=0.3)
    
    # 2. Scatter plot de las dos variables principales
    if len(numeric_cols) >= 2:
        # Usar las primeras dos variables num√©ricas
        x_col = numeric_cols[0]
        y_col = numeric_cols[1]
        
        # Crear scatter plot separado
        plt.figure(figsize=(10, 8))
        plt.scatter(df[x_col], df[y_col], alpha=0.6, s=50)
        plt.title(f'Relaci√≥n entre {x_col} y {y_col}')
        plt.xlabel(x_col)
        plt.ylabel(y_col)
        plt.grid(True, alpha=0.3)
        
        # TODO 6: Guardar las figuras en ./output_kmeans/ con nombres descriptivos
        
        plt.savefig('./output_kmeans/scatter_exploratorio.png', dpi=300, bbox_inches='tight')
        print("‚úÖ Scatter plot guardado: scatter_exploratorio.png")
        plt.close()
    
    # Guardar figura principal
    plt.savefig('./output_kmeans/histogramas_exploratorio.png', dpi=300, bbox_inches='tight')
    print("‚úÖ Histogramas guardados: histogramas_exploratorio.png")
    plt.close()
    
    print("‚úÖ Visualizaciones exploratorias completadas")

def preparar_datos(df):
    """
    Prepara los datos para el clustering
    """
    # TODO 7: Seleccionar solo las 2 variables num√©ricas que usar√°s para clustering
    # Sugerencia: "Annual Income (k$)" y "Spending Score (1-100)"
    
    print("üîß Preparando datos para clustering...")
    
    # Buscar las columnas sugeridas
    target_cols = []
    for col in df.columns:
        if 'income' in col.lower():
            target_cols.append(col)
        elif 'spending' in col.lower() or 'score' in col.lower():
            target_cols.append(col)
    
    # Si no se encuentran las columnas espec√≠ficas, usar las primeras 2 num√©ricas
    if len(target_cols) < 2:
        numeric_cols = df.select_dtypes(include=[np.number]).columns
        target_cols = list(numeric_cols[:2])
        print(f"‚ö†Ô∏è Usando primeras 2 variables num√©ricas: {target_cols}")
    else:
        print(f"‚úÖ Variables seleccionadas: {target_cols}")
    
    # Seleccionar solo las columnas objetivo
    X = df[target_cols].copy()
    print(f"üìä Datos seleccionados: {X.shape}")
    
    # TODO 8: Decidir si escalar los datos o no
    # Si escalas, guarda el scaler para poder revertir los centroides despu√©s
    
    # Escalar los datos para mejor rendimiento del clustering
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    
    print("‚úÖ Datos escalados usando StandardScaler")
    print(f"üìä Datos originales - Rango: {X.min().min():.2f} a {X.max().max():.2f}")
    print(f"üìä Datos escalados - Rango: {X_scaled.min():.2f} a {X_scaled.max():.2f}")
    
    # TODO 9: Verificar que los datos est√°n en el formato correcto (numpy array)
    
    if isinstance(X_scaled, np.ndarray):
        print("‚úÖ Datos en formato numpy array correcto")
        return X_scaled, scaler, target_cols
    else:
        print("‚ùå Error: Los datos no est√°n en formato numpy array")
        return None, None, None

def calcular_metricas_kmeans(X, k_range):
    """
    Calcula SSE y Silhouette para diferentes valores de K
    """
    sse_values = []
    silhouette_values = []
    
    print("üîç Calculando m√©tricas para diferentes valores de K...")
    
    # TODO 10: Para cada K en k_range (2 a 7):
    # - Entrenar KMeans con ese K
    # - Calcular SSE (inertia_)
    # - Calcular Silhouette Score
    # - Guardar ambos valores en las listas correspondientes
    
    for k in k_range:
        print(f"  üìä Probando K = {k}...")
        
        # Entrenar KMeans con ese K
        kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
        kmeans.fit(X)
        
        # Calcular SSE (inertia_)
        sse = kmeans.inertia_
        sse_values.append(sse)
        
        # Calcular Silhouette Score
        labels = kmeans.labels_
        if k > 1:  # Silhouette score solo funciona con k > 1
            silhouette = silhouette_score(X, labels)
            silhouette_values.append(silhouette)
        else:
            silhouette_values.append(0)
        
        print(f"    ‚úÖ K={k}: SSE={sse:.2f}, Silhouette={silhouette:.3f}")
    
    print("‚úÖ C√°lculo de m√©tricas completado")
    return sse_values, silhouette_values

def graficar_curva_codo(sse_values, k_range):
    """
    Grafica la curva del codo (SSE vs K)
    """
    # TODO 11: Crear gr√°fico de l√≠nea de SSE vs K
    # - Usar plt.plot() para la l√≠nea
    # - Agregar marcadores en los puntos
    # - Etiquetar ejes y t√≠tulo
    # - Agregar grid
    
    print("üìà Generando gr√°fico de curva del codo...")
    
    plt.figure(figsize=(10, 8))
    plt.plot(k_range, sse_values, 'bo-', linewidth=2, markersize=8)
    plt.xlabel('N√∫mero de Clusters (K)', fontsize=12)
    plt.ylabel('Suma de Errores Cuadrados (SSE)', fontsize=12)
    plt.title('Curva del Codo - SSE vs K', fontsize=14)
    plt.grid(True, alpha=0.3)
    
    # Agregar anotaciones de valores
    for i, (k, sse) in enumerate(zip(k_range, sse_values)):
        plt.annotate(f'{sse:.0f}', (k, sse), textcoords="offset points", 
                    xytext=(0,10), ha='center', fontsize=10)
    
    # TODO 12: Guardar la figura en ./output_kmeans/curva_codo.png
    
    plt.savefig('./output_kmeans/curva_codo.png', dpi=300, bbox_inches='tight')
    print("‚úÖ Curva del codo guardada: curva_codo.png")
    plt.close()

def graficar_silhouette(silhouette_values, k_range):
    """
    Grafica el score de Silhouette vs K
    """
    # TODO 13: Crear gr√°fico de barras de Silhouette vs K
    # - Usar plt.bar() para las barras
    # - Etiquetar ejes y t√≠tulo
    # - Agregar grid
    
    print("üìä Generando gr√°fico de scores de Silhouette...")
    
    plt.figure(figsize=(10, 8))
    bars = plt.bar(k_range, silhouette_values, color='skyblue', edgecolor='navy', alpha=0.7)
    plt.xlabel('N√∫mero de Clusters (K)', fontsize=12)
    plt.ylabel('Silhouette Score', fontsize=12)
    plt.title('Silhouette Score vs K', fontsize=14)
    plt.grid(True, alpha=0.3, axis='y')
    
    # Agregar valores en las barras
    for bar, score in zip(bars, silhouette_values):
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                f'{score:.3f}', ha='center', va='bottom', fontsize=10)
    
    # TODO 14: Guardar la figura en ./output_kmeans/silhouette_scores.png
    
    plt.savefig('./output_kmeans/silhouette_scores.png', dpi=300, bbox_inches='tight')
    print("‚úÖ Gr√°fico de Silhouette guardado: silhouette_scores.png")
    plt.close()

def seleccionar_k_optimo(sse_values, silhouette_values, k_range):
    """
    Selecciona el K √≥ptimo basado en las m√©tricas
    """
    # TODO 15: Analizar las m√©tricas y seleccionar el mejor K
    # - Considerar tanto la curva del codo como los scores de silhouette
    # - Documentar tu decisi√≥n en comentarios
    
    print("üéØ Seleccionando K √≥ptimo...")
    
    try:
        # Encontrar el K con mayor Silhouette score
        max_silhouette_idx = np.argmax(silhouette_values)
        k_silhouette = k_range[max_silhouette_idx]
        max_silhouette = silhouette_values[max_silhouette_idx]
        
        # Encontrar el "codo" en la curva SSE usando m√©todo m√°s robusto
        # Calcular la segunda derivada para encontrar el punto de inflexi√≥n
        if len(sse_values) > 2:
            sse_diff = np.diff(sse_values)
            sse_diff2 = np.diff(sse_diff)
            if len(sse_diff2) > 0:
                elbow_idx = np.argmin(sse_diff2) + 1  # +1 porque diff reduce el tama√±o
                k_elbow = k_range[elbow_idx]
            else:
                k_elbow = k_range[1]  # Usar segundo valor si no hay suficientes datos
        else:
            k_elbow = k_range[1] if len(k_range) > 1 else k_range[0]
        
        print(f"üìä K con mayor Silhouette: {k_silhouette} (score: {max_silhouette:.3f})")
        print(f"üìä K sugerido por curva del codo: {k_elbow}")
        
        # TODO 16: Retornar el K seleccionado
        
        # Seleccionar K basado en Silhouette (m√°s confiable para clustering)
        k_optimo = k_silhouette
        
        print(f"‚úÖ K √≥ptimo seleccionado: {k_optimo}")
        print(f"üí° Justificaci√≥n: Mayor Silhouette score ({max_silhouette:.3f}) indica mejor separaci√≥n entre clusters")
        
        return k_optimo
        
    except Exception as e:
        print(f"‚ùå Error al seleccionar K √≥ptimo: {e}")
        # Fallback: usar K=3 como valor por defecto
        print("‚ö†Ô∏è Usando K=3 como valor por defecto")
        return 3

def entrenar_kmeans_final(X, k_optimo, scaler=None):
    """
    Entrena el modelo K-Means final con el K √≥ptimo
    """
    # TODO 17: Entrenar KMeans con el K √≥ptimo
    
    print(f"üöÄ Entrenando modelo final con K = {k_optimo}...")
    
    kmeans_final = KMeans(n_clusters=k_optimo, random_state=42, n_init=10)
    kmeans_final.fit(X)
    
    # TODO 18: Obtener las etiquetas de cluster y centroides
    
    labels = kmeans_final.labels_
    centroids = kmeans_final.cluster_centers_
    
    print(f"‚úÖ Modelo entrenado exitosamente")
    print(f"üìä Etiquetas generadas: {len(labels)}")
    print(f"üìä Centroides: {centroids.shape}")
    
    # TODO 19: Calcular m√©tricas finales (SSE y Silhouette)
    
    sse_final = kmeans_final.inertia_
    silhouette_final = silhouette_score(X, labels)
    
    print(f"üìà SSE final: {sse_final:.2f}")
    print(f"üìà Silhouette final: {silhouette_final:.3f}")
    
    # TODO 20: Si escalaste los datos, revertir los centroides a la escala original
    
    if scaler is not None:
        centroids_original = scaler.inverse_transform(centroids)
        print("‚úÖ Centroides revertidos a escala original")
        centroids = centroids_original
    else:
        print("‚ÑπÔ∏è No se aplic√≥ escalado, centroides en escala original")
    
    return kmeans_final, labels, centroids, sse_final, silhouette_final

def visualizar_clusters(X, labels, centroids, k_optimo):
    """
    Visualiza los clusters resultantes
    """
    # TODO 21: Crear scatter plot de los clusters
    # - Usar colores diferentes para cada cluster
    # - Marcar los centroides con s√≠mbolos especiales
    # - Agregar leyenda, etiquetas de ejes y t√≠tulo
    
    print("üé® Generando visualizaci√≥n de clusters finales...")
    
    # Validar datos de entrada
    if X is None or labels is None or centroids is None:
        print("‚ùå Error: Datos de entrada inv√°lidos para visualizaci√≥n")
        return
    
    if len(labels) != len(X):
        print("‚ùå Error: N√∫mero de etiquetas no coincide con n√∫mero de datos")
        return
    
    try:
        plt.figure(figsize=(12, 10))
        
        # Colores para los clusters
        colors = plt.cm.Set3(np.linspace(0, 1, k_optimo))
        
        # Scatter plot para cada cluster
        for i in range(k_optimo):
            cluster_points = X[labels == i]
            if len(cluster_points) > 0:  # Verificar que el cluster no est√© vac√≠o
                plt.scatter(cluster_points[:, 0], cluster_points[:, 1], 
                           c=[colors[i]], label=f'Cluster {i} ({len(cluster_points)} puntos)', 
                           alpha=0.7, s=50)
        
        # Marcar centroides
        plt.scatter(centroids[:, 0], centroids[:, 1], 
                   c='red', marker='x', s=200, linewidths=3, 
                   label='Centroides', zorder=5)
        
        # Agregar anotaciones de centroides
        for i, centroid in enumerate(centroids):
            plt.annotate(f'C{i}', (centroid[0], centroid[1]), 
                        xytext=(5, 5), textcoords='offset points',
                        fontsize=12, fontweight='bold', color='red')
        
        plt.xlabel('Variable 1 (escalada)', fontsize=12)
        plt.ylabel('Variable 2 (escalada)', fontsize=12)
        plt.title(f'Clusters Finales - K-Means con K={k_optimo}', fontsize=14)
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        # TODO 22: Guardar la figura en ./output_kmeans/clusters_finales.png
        
        plt.savefig('./output_kmeans/clusters_finales.png', dpi=300, bbox_inches='tight')
        print("‚úÖ Visualizaci√≥n de clusters guardada: clusters_finales.png")
        plt.close()
        
    except Exception as e:
        print(f"‚ùå Error al generar visualizaci√≥n: {e}")
        plt.close()  # Cerrar figura en caso de error

def exportar_resultados(df_original, labels, centroids, k_optimo):
    """
    Exporta los resultados del clustering
    """
    # TODO 23: Crear DataFrame con las etiquetas de cluster
    # - Agregar columna 'Cluster' al DataFrame original
    
    print("üíæ Exportando resultados del clustering...")
    
    try:
        # Crear copia del DataFrame original
        df_con_clusters = df_original.copy()
        df_con_clusters['Cluster'] = labels
        
        print(f"‚úÖ Columna 'Cluster' agregada al DataFrame")
        print(f"üìä Distribuci√≥n de clusters:")
        cluster_counts = df_con_clusters['Cluster'].value_counts().sort_index()
        for cluster, count in cluster_counts.items():
            print(f"   Cluster {cluster}: {count} clientes")
        
        # TODO 24: Guardar DataFrame con etiquetas en ./output_kmeans/clientes_clusterizados.csv
        
        output_path = './output_kmeans/clientes_clusterizados.csv'
        df_con_clusters.to_csv(output_path, index=False)
        print(f"‚úÖ DataFrame con clusters guardado: {output_path}")
        
        # TODO 25: Crear DataFrame con los centroides
        # - Incluir coordenadas de los centroides
        # - Guardar en ./output_kmeans/centroides_clusters.csv
        
        # Obtener nombres de columnas originales (sin escalar)
        if hasattr(df_original, 'columns'):
            feature_names = list(df_original.select_dtypes(include=[np.number]).columns[:2])
        else:
            feature_names = ['Variable_1', 'Variable_2']
        
        # Crear DataFrame de centroides
        df_centroides = pd.DataFrame(centroids, columns=feature_names)
        df_centroides['Cluster'] = range(k_optimo)
        
        centroides_path = './output_kmeans/centroides_clusters.csv'
        df_centroides.to_csv(centroides_path, index=False)
        print(f"‚úÖ Centroides guardados: {centroides_path}")
        
        print("‚úÖ Exportaci√≥n de resultados completada")
        
    except Exception as e:
        print(f"‚ùå Error al exportar resultados: {e}")
        print("‚ö†Ô∏è Verifica que tienes permisos de escritura en la carpeta output_kmeans/")

def generar_reporte_final(k_optimo, sse_final, silhouette_final, centroids):
    """
    Genera un reporte final con las m√©tricas y resultados
    """
    print("=" * 60)
    print("REPORTE FINAL - SEGMENTACI√ìN DE CLIENTES CON K-MEANS")
    print("=" * 60)
    
    # TODO 26: Mostrar informaci√≥n del modelo final:
    # - K seleccionado y justificaci√≥n
    # - SSE final
    # - Silhouette Score final
    # - Coordenadas de los centroides
    
    print(f"\nüéØ RESUMEN DEL MODELO FINAL:")
    print(f"   ‚Ä¢ K seleccionado: {k_optimo}")
    print(f"   ‚Ä¢ SSE final: {sse_final:.2f}")
    print(f"   ‚Ä¢ Silhouette Score final: {silhouette_final:.3f}")
    
    print(f"\nüí° INTERPRETACI√ìN:")
    if silhouette_final > 0.7:
        print(f"   ‚Ä¢ Excelente separaci√≥n entre clusters (Silhouette > 0.7)")
    elif silhouette_final > 0.5:
        print(f"   ‚Ä¢ Buena separaci√≥n entre clusters (Silhouette > 0.5)")
    elif silhouette_final > 0.25:
        print(f"   ‚Ä¢ Separaci√≥n moderada entre clusters (Silhouette > 0.25)")
    else:
        print(f"   ‚Ä¢ Separaci√≥n d√©bil entre clusters (Silhouette ‚â§ 0.25)")
    
    print(f"\nüìç CENTROIDES DE LOS CLUSTERS:")
    for i, centroid in enumerate(centroids):
        print(f"   ‚Ä¢ Cluster {i}: {centroid}")
    
    print(f"\nüìä ARCHIVOS GENERADOS:")
    print(f"   ‚Ä¢ Gr√°ficos: ./output_kmeans/")
    print(f"   ‚Ä¢ Datos: ./output_kmeans/clientes_clusterizados.csv")
    print(f"   ‚Ä¢ Centroides: ./output_kmeans/centroides_clusters.csv")
    
    print("\n" + "=" * 60)

def main():
    """
    Funci√≥n principal que ejecuta todo el flujo del ejercicio
    """
    print("üöÄ Iniciando ejercicio de K-Means para segmentaci√≥n de clientes...")
    print("=" * 60)
    
    # Crear directorios
    print("üìÅ PASO 1/11: Creando directorios...")
    crear_directorios()
    
    # Cargar datos
    print("\nüìä PASO 2/11: Cargando datos...")
    df = cargar_datos()
    
    if df is None:
        print("‚ùå Error: No se pudieron cargar los datos. Verifica que el archivo existe en ./input/")
        return
    
    # Explorar datos
    print("\nüîç PASO 3/11: Explorando datos...")
    explorar_datos(df)
    
    # Preparar datos
    print("\n‚öôÔ∏è PASO 4/11: Preparando datos para clustering...")
    X, scaler, target_cols = preparar_datos(df)
    
    if X is None:
        print("‚ùå Error: No se pudieron preparar los datos.")
        return
    
    # Calcular m√©tricas para diferentes K
    print("\nüìà PASO 5/11: Calculando m√©tricas para diferentes valores de K...")
    k_range = range(2, 8)
    sse_values, silhouette_values = calcular_metricas_kmeans(X, k_range)
    
    # Graficar curva del codo
    print("\nüìä PASO 6/11: Generando gr√°fico de curva del codo...")
    graficar_curva_codo(sse_values, k_range)
    
    # Graficar scores de silhouette
    print("\nüìä PASO 7/11: Generando gr√°fico de scores de silhouette...")
    graficar_silhouette(silhouette_values, k_range)
    
    # Seleccionar K √≥ptimo
    print("\nüéØ PASO 8/11: Seleccionando K √≥ptimo...")
    k_optimo = seleccionar_k_optimo(sse_values, silhouette_values, k_range)
    
    if k_optimo is None:
        print("‚ùå Error: No se pudo seleccionar K √≥ptimo. Verifica la funci√≥n seleccionar_k_optimo.")
        return
    
    # Entrenar modelo final
    print(f"\nüöÄ PASO 9/11: Entrenando modelo final con K={k_optimo}...")
    kmeans_final, labels, centroids, sse_final, silhouette_final = entrenar_kmeans_final(X, k_optimo, scaler)
    
    if any(x is None for x in [kmeans_final, labels, centroids, sse_final, silhouette_final]):
        print("‚ùå Error: No se pudo entrenar el modelo final. Verifica la funci√≥n entrenar_kmeans_final.")
        return
    
    # Visualizar clusters
    print("\nüé® PASO 10/11: Generando visualizaci√≥n de clusters...")
    visualizar_clusters(X, labels, centroids, k_optimo)
    
    # Exportar resultados
    print("\nüíæ PASO 11/11: Exportando resultados...")
    exportar_resultados(df, labels, centroids, k_optimo)
    
    # Generar reporte final
    print("\nüìã Generando reporte final...")
    generar_reporte_final(k_optimo, sse_final, silhouette_final, centroids)
    
    print("\nüéâ ¬°Ejercicio completado exitosamente!")
    print("üìÅ Revisa la carpeta ./output_kmeans/ para ver todos los resultados.")
    print("=" * 60)

def verificar_sintaxis():
    """
    Funci√≥n para verificar que el c√≥digo se ejecute sin errores de sintaxis
    """
    try:
        print("üîç Verificando sintaxis del c√≥digo...")
        print("‚úÖ C√≥digo sint√°cticamente correcto")
        print("‚úÖ Todas las funciones est√°n definidas correctamente")
        print("‚úÖ Imports est√°n correctos")
        print("‚úÖ Estructura del ejercicio lista para completar")
        
        # Verificar versiones de las librer√≠as
        print("\nüìö Versiones de librer√≠as:")
        print(f"   ‚Ä¢ NumPy: {np.__version__}")
        print(f"   ‚Ä¢ Pandas: {pd.__version__}")
        print(f"   ‚Ä¢ Matplotlib: {plt.matplotlib.__version__}")
        print(f"   ‚Ä¢ Scikit-learn: {sklearn.__version__}")
        
        return True
    except Exception as e:
        print(f"‚ùå Error de sintaxis: {e}")
        return False

if __name__ == "__main__":
    # Verificar sintaxis primero
    if verificar_sintaxis():
        print("\n" + "="*60)
        main()
    else:
        print("Corrige los errores de sintaxis antes de continuar.")
